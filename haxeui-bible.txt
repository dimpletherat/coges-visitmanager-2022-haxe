IanHarriganAujourd’hui à 12:25
(eventually btw, the style is going to be renamed to computedStyle and customStyle is going to be renamed to style)
do you want it to be a variable?
cant you just do:

.something {
    background-color: red;
}

.somethingElse {
   background-color: #00ff00;
}

dimpletheratAujourd’hui à 12:34
yeah it will be a variable. Red was an example, but it could be any value.
I guess i should go the "Theme" route, but I have no time to dive deep into the proper styling process
(I'll try customStyle. but styleString works too :slight_smile: )
IanHarriganAujourd’hui à 12:35
yeah, personally, to keep things neat, i would probably do something like:

<style>
.myStyle {
    background-color: red;
}
<style>
<button styleNames="myStyle" />

and if you wanted .myStyle to be more dynamic then you could build that style at runtime using something like:

Toolkit.styleSheet.parse('.myStyle { background-color: ${Config.colors.RED}; }');

fyi: .styleString just splits and parses the css string into .customStyle (iirc)
--------------------------------------------

IanHarriganAujourd’hui à 09:56
Hi!

Yeah, the documentation is pretty slim :(
I think ive said about 100 times that i want to improve it, but i just never get time (motivation is probably more honest) and end up just working on the actual framework.

So for components children usually you can look in the styles and it will give you a fairly good indication of what children a component contains, for example:

https://github.com/haxeui/haxeui-core/blob/master/haxe/ui/_module/styles/default/scrollbars.css

So we can see from there there are 3 buttons that are in a scrollbar: inc, deinc, thumb. So you could do:

.scroll .inc, .scroll .deinc {
    hidden: true;
}


note that "hidden" isnt actually a css3 property but is specific to haxeui, i keep meaning to also add "display: none" but i havent gotten around to it yet 

for text (labels) i think you have: font-size, font-name, font-bold, font-italic, font-underline and color - again, alot of these arent css3 properties and i should really add the css3 version too for clarity

For the itemrenderer i guess you have a few options... there is and itemRendererFn which means you can return the correct item renderer based on your data, however, this was added A LONG time ago and so it very well may not work as intended, ill have to give it another run over at some point. Another options would be to subclass item renderer (MyItemRenderer extends ItemRenderer) and then have logic in there, maybe on the override the validateComponentData call (make sure you call the super though!). Ill have a think though how the API could be nicer here - open to suggestions ofc - and a solid test app / use case is always useful if you have one :wink:
So the metadata on fields do specific things, and for the most part you really dont need to work about anything to do with them (unless you are building your own, cross framework components - which is "all" haxeui-core is essentially), but heres a brief rundown:

@:clonable - this tells haxeui to automatically include this field when it auto builds the "cloneComponent" function... you can build your own "cloneComponent" (and haxuei macros will add to it), but this is a shortcut to not have to remember to do that
@:bindable - this means that the field can be used for binding, which means you can use it xml like <button text='value is ${mySlider.pos + 22} />, in this case .pos of the slider would need to be annotated with @:bindable
@:behaviour - these are pretty complex, but basically haxeui is behavior driven, this means that when you call "myButton.text" rather than that lead directly to some code that does stuff it leads to a behviour that does stuff - the reason is because haxeui is cross framework and supports native backends... Backends are split into two broad categories: Composite (where haxeui handles all the internals) and Native (where haxeui delegates component creation and behaviours to a backed).

So take openfl and hxwidgets: .text leads to a default behaviour (which is a composite based beahviour) which will create a haxeui Label component, add it to the button, tell haxeui the composite layout is invalid and get it recalc all that - that'll kick in for composite backends (openfl, nme, kha, heaps, etc, etc)... however, for native backends that aint gonna work, the component is a native button window and we dont want to add a label to that (as its handled by the native framework) and we dont control the layout. So the behaviour that gets called is overridden from that composite one, to one that can do anything it wants (in this case it will set the text of the underlying native button text directly)
for the most part you wont really need to use that, unless you are creating you own cross framework component suite
clonable and bindable are arguably more important but only if you are creating your own custom components ofc (and want them to work with things like ItemRenderers, which uses cloneComponent) and have xml accessible binding
sorry for the "wall of text"... :smile:

---------------------------------

		
		/*
		var scroll:VerticalScroll = findComponent(null, VerticalScroll);
		scroll.customStyle.opacity = 0.5;
		scroll.customStyle.width = 12;
		scroll.customStyle.paddingLeft = 2;
		scroll.customStyle.paddingRight = 2;
		scroll.customStyle.paddingTop = 2;
		scroll.customStyle.paddingBottom = 2;
		scroll.customStyle.backgroundColor = 0x990000;*/
		
		/*
<hbox>
<style>

			.scroll .inc, .scroll .deinc 
			{ 
			hidden: true;
			}
			.vertical-scroll {
    opacity: .5;
    width: 12px;
    padding: 2px;
    background-color: none;
}
.vertical-scroll .thumb {
    width: 8px;
	min-height:60px;
    border-radius: 2px;
}
</style>
</hbox>*/
		
/*
		var scroll:VerticalScroll = findComponent(null, VerticalScroll);
		//scroll.customStyle.
		var s:Style = scroll.style;
		s.opacity = 0.5;
		s.width = 12;
		s.paddingLeft = 2;
		s.paddingRight = 2;
		s.paddingTop = 2;
		s.paddingBottom = 2;
		s.backgroundColor = 0x990000;
		scroll.style = s;
		scroll.styleString = "opacity:0.5;padding:3px;width:12px;background-color:none";
		var btInc:Component = findComponent("inc", null, true, "css");
		btInc.hidden = true;
		var btDeinc:Component = findComponent("deinc", null, true, "css");
		btDeinc.hidden = true;
		var thumb:Component = findComponent("thumb", null, true, "css");
		thumb.styleString = "min-height:60px;width:6px;border-radius:2px";
		/*thumb.style.width = 8;
		thumb.style.minWidth = 60;
		thumb.style.borderRadius = 2;*/